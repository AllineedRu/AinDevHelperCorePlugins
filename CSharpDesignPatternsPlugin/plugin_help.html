<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C# Design Patterns Plugin</title>
    <link rel="stylesheet" type="text/css" href="./../common-plugin-styles.css" />
</head>
<body>
    <h1 id="toc" class="title">C# Design Patterns Plugin - Документация</h1>
    <h2>О плагине</h2>
    <p class="justify">
		Плагин, который помогает разработчику быстро генерировать примеры кода на языке C# для различных известных шаблонов проектирования (паттернов). 
        Плагин содержит различные действия, включая действия на генерацию, которые генерируют готовые проекты (тип каждого проекта - консольное приложение) на языке C# для среды Microsoft Visual Studio с примером кода по выбранному шаблону проектирования.
        Каждый из сгенерированных демонстрационных проектов показывает применение конкретного шаблона проектирования в определённой практической задаче-примере и нацелен на то, чтобы помочь разработчику адаптировать 
        готовый сгенерированный пример-шаблон под любые другие аналогичные задачи, необходимые разработчику в его программах.
	</p>    
    <h2>Поддерживаемые действия плагина</h2>
    <p>Плагин поддерживает следующие действия:</p>
    <ul>
        <li><a href="#action_clean_generated_directory">Очистить каталог 'generated' плагина</a></li>
		<li><a href="#action_generate_behavioral_visitor_pattern">[Поведенческие] Сгенерировать шаблон 'Посетитель' (Visitor)</a></li>
		<li><a href="#action_generate_behavioral_chain_of_responsibility_pattern">[Поведенческие] Сгенерировать шаблон 'Цепочка обязанностей' (Chain Of Responsibility)</a></li>
		<li><a href="#action_generate_behavioral_command_pattern">[Поведенческие] Сгенерировать шаблон 'Команда' (Command)</a></li>
		<li><a href="#action_generate_behavioral_template_method_pattern">[Поведенческие] Сгенерировать шаблон 'Шаблонный метод' (Template Method)</a></li>
        <li><a href="#action_generate_behavioral_null_object_pattern">[Поведенческие] Сгенерировать шаблон 'Нулевой объект' (Null Object)</a></li>
        <li><a href="#action_generate_behavioral_strategy_pattern">[Поведенческие] Сгенерировать шаблон 'Стратегия' (Strategy)</a></li>
        <li><a href="#action_generate_behavioral_observer_pattern">[Поведенческие] Сгенерировать шаблон 'Наблюдатель' (Observer)</a></li>
        <li><a href="#action_generate_behavioral_state_pattern">[Поведенческие] Сгенерировать шаблон 'Состояние' (State)</a></li>
        <li><a href="#action_generate_behavioral_memento_pattern">[Поведенческие] Сгенерировать шаблон 'Хранитель' (Memento)</a></li>
        <li><a href="#action_generate_behavioral_mediator_pattern">[Поведенческие] Сгенерировать шаблон 'Посредник' (Mediator)</a></li>
        <li><a href="#action_generate_behavioral_iterator_pattern">[Поведенческие] Сгенерировать шаблон 'Итератор' (Iterator)</a></li>
        <li><a href="#action_generate_creational_abstract_factory_pattern">[Порождающие] Сгенерировать шаблон 'Абстрактная фабрика' (Abstract Factory)</a></li>
        <li><a href="#action_generate_creational_builder_pattern">[Порождающие] Сгенерировать шаблон 'Строитель' (Builder)</a></li>
        <li><a href="#action_generate_creational_factory_method_pattern">[Порождающие] Сгенерировать шаблон 'Фабричный метод' (Factory Method)</a></li>
        <li><a href="#action_generate_creational_not_thread_safe_singleton_pattern">[Порождающие] Сгенерировать шаблон 'Одиночка' (Singleton) - не потокобезопасный</a></li>
        <li><a href="#action_generate_creational_thread_safe_singleton_pattern">[Порождающие] Сгенерировать шаблон 'Одиночка' (Singleton) - потокобезопасный</a></li>
        <li><a href="#action_generate_creational_object_pool_pattern">[Порождающие] Сгенерировать шаблон 'Пул объектов' (Object Pool)</a></li>
        <li><a href="#action_generate_creational_prototype_pattern">[Порождающие] Сгенерировать шаблон 'Прототип' (Prototype)</a></li>
        <li><a href="#action_generate_structural_adapter_pattern">[Структурные] Сгенерировать шаблон 'Адаптер' (Adapter)</a></li>
        <li><a href="#action_generate_structural_bridge_pattern">[Структурные] Сгенерировать шаблон 'Мост' (Bridge)</a></li>
        <li><a href="#action_generate_structural_decorator_pattern">[Структурные] Сгенерировать шаблон 'Декоратор' (Decorator)</a></li>
        <li><a href="#action_generate_structural_composite_pattern">[Структурные] Сгенерировать шаблон 'Компоновщик' (Composite)</a></li>
        <li><a href="#action_generate_structural_flyweight_pattern">[Структурные] Сгенерировать шаблон 'Приспособленец/Легковес' (Flyweight)</a></li>
        <li><a href="#action_generate_structural_proxy_pattern">[Структурные] Сгенерировать шаблон 'Заместитель' (Proxy)</a></li>
        <li><a href="#action_generate_structural_router_pattern">[Структурные] Сгенерировать шаблон 'Маршрутизатор' (Router)</a></li>
        <li><a href="#action_generate_structural_facade_pattern">[Структурные] Сгенерировать шаблон 'Фасад' (Facade)</a></li>
        <li><a href="#action_generate_technique_cascading_method">[Техники] Сгенерировать пример проекта для техники 'Каскадный метод' (Cascading Method)</a></li>
    </ul>

    <h2>Описание действий</h2>
    
	<p>Ниже приводится описание работы действий, поддерживаемых плагином.</p>
    
	<h3 id="action_clean_generated_directory">Очистить каталог 'generated' плагина</h3>
	<p class="justify">Действие очищает всё содержимое каталога <b>generated</b>, расположенного внутри каталога плагина, таким образом стирая все предыдущие сгенерированные плагином примеры кода с шаблонами проектирования и/или техниками.</p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_visitor_pattern">[Поведенческие] Сгенерировать шаблон 'Посетитель' (Visitor)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Посетитель' (Visitor). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>visitor</b> каталога <b>generated</b>.
    </p>
    <p class="justify">В этом примере классы <span class="code">Circle</span>, <span class="code">Square</span>, <span class="code">Triangle</span> и <span class="code">Rectangle</span> 
        представляют различные геометрические фигуры, а класс <span class="code">AreaVisitor</span> реализует интерфейс посетителя <span class="code">IVisitor</span> для вычисления площади каждой фигуры.
        Метод <span class="code">Accept</span> в каждом классе фигуры вызывает соответствующий метод посетителя для вычисления площади фигуры.
        При запуске программы для сгенерированного действием проекта будет выведено сообщение с площадями круга, квадрата, треугольника и прямоугольника, не изменяя при этом сами классы этих фигур.
        Таким образом, паттерн "Посетитель" позволяет добавлять новые операции над объектами без изменения самих объектов.
    </p>

    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_chain_of_responsibility_pattern">[Поведенческие] Сгенерировать шаблон 'Цепочка обязанностей' (Chain Of Responsibility)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Цепочка обязанностей' (Chain Of Responsibility). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>chain_of_responsibility</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлена ситуация, где у нас есть система обработки заявок на кредит. 
        У нас есть несколько уровней одобрения кредита, и каждый уровень должен принять решение о том, одобрять ли заявку или передавать её на следующий уровень. 
        В этом примере классы <span class="code">BankManager</span> и <span class="code">LoanManager</span> реализуют общий интерфейс <span class="code">ICreditApprover</span> и представляют различные уровни одобрения кредита, 
        а класс <span class="code">CreditRequest</span> представляет саму заявку на кредит. Каждый обработчик решает, может ли он одобрить заявку, и если нет, 
        передает её следующему обработчику в цепочке. Таким образом реализуется паттерн 'Цепочка обязанностей'.
    </p>    
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_command_pattern">[Поведенческие] Сгенерировать шаблон 'Команда' (Command)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Команда' (Command). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>command</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлена ситуация, где у нас есть робот, который умеет выполнять различные команды, такие как движение вперед и назад. 
        Мы можем использовать паттерн 'Команда' для управления этими командами. В этом примере мы создаем интерфейс <span class="code">ICommand</span>, который представляет команду. 
        Затем у нас есть конкретные классы команд <span class="code">MoveForwardCommand</span> и <span class="code">MoveBackwardCommand</span>, 
        которые реализуют этот интерфейс. Класс <span class="code">Robot</span> представляет собой объект, над которым выполняются команды. <span class="code">CommandExecutor</span> отвечает за выполнение команд. 
        В методе <span class="code">Main</span> программы-примера создается объект робота и команды для движения вперед и назад. Затем эти команды передаются в <span class="code">CommandExecutor</span>, который их выполняет.
    </p>

    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_template_method_pattern">[Поведенческие] Сгенерировать шаблон 'Шаблонный метод' (Template Method)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Шаблонный метод' (Template Method). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>template_method</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлена ситуация, где у нас есть базовый класс <span class="code">DataProcessor</span>, который определяет шаблон для обработки данных. 
        У нас также есть два подкласса <span class="code">CsvDataProcessor</span> и <span class="code">ExcelDataProcessor</span>, которые реализуют специфические шаги для обработки данных из файлов CSV и Excel соответственно. 
        В этом примере абстрактный класс <span class="code">DataProcessor</span> определяет шаблонный метод <span class="code">ProcessData</span>, который вызывает последовательность операций 
        для обработки данных: чтение, парсинг и анализ. Подклассы CsvDataProcessor и ExcelDataProcessor реализуют конкретные шаги этих операций в соответствии с форматом файла (CSV или Excel). 
        В методе <span class="code">Main</span> создаются экземпляры классов <span class="code">CsvDataProcessor</span> и <span class="code">ExcelDataProcessor</span>, после чего вызывается метод <span class="code">ProcessData</span>, 
        который последовательно выполняет все шаги обработки данных в соответствии с шаблоном, определенным в базовом классе.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_null_object_pattern">[Поведенческие] Сгенерировать шаблон 'Нулевой объект' (Null Object)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Нулевой объект' (Null Object). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>null_object</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        Паттерн 'Нулевой объект' (Null Object) используется для предоставления объекта-заглушки, который реализует интерфейс, но не выполняет никаких действий. 
        Этот паттерн полезен, когда необходимо избежать проверок на null и обеспечить более безопасное поведение программы. 
        В сгенерированной действием программе-примере рассмотрен вариант применения паттерна 'Нулевой объект' на примере логгирования в приложении. 
        У нас есть интерфейс <span class="code">ILogger</span>, который определяет метод для записи логов. Мы создадим два класса: <span class="code">FileLogger</span>, который сохраняет логи в файл, 
        и <span class="code">NullLogger</span>, который представляет нулевой объект и не выполняет никаких действий. 
        В данном примере, если мы используем <span class="code">FileLogger</span>, то логи будут записываться в файл. Однако, если мы заменим <span class="code">FileLogger</span> на <span class="code">NullLogger</span>, 
        то операции записи логов будут проходить без ошибок, но никакой реальной записи не будет произведено. 
        Это позволяет избежать проверок на null и обеспечить более гладкое выполнение программы.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_strategy_pattern">[Поведенческие] Сгенерировать шаблон 'Стратегия' (Strategy)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Стратегия' (Strategy). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>strategy</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        Паттерн 'Стратегия' (Strategy) используется для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. 
        В сгенерированной действием программе-примере рассмотрен вариант применения паттерна 'Стратегия' на примере обработки платежей в интернет-магазине. 
        У нас есть интерфейс <span class="code">IPaymentStrategy</span>, который определяет метод для проведения платежа, и две конкретные реализации этого интерфейса: 
        <span class="code">CreditCardPaymentStrategy</span> для оплаты кредитной картой и <span class="code">PayPalPaymentStrategy</span> для оплаты через PayPal. 
        В данном примере мы создаем две стратегии для обработки платежей: оплата кредитной картой и оплата через PayPal. 
        Затем мы создаем экземпляры класса <span class="code">PaymentProcessor</span>, каждому из которых передаем конкретную стратегию. 
        При вызове метода <span class="code">ProcessOrder</span> у <span class="code">PaymentProcessor</span> будет выполнен соответствующий алгоритм оплаты в зависимости от выбранной стратегии. 
        Это позволяет легко добавлять новые способы оплаты без изменения основного кода и обеспечивает гибкость системы.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_observer_pattern">[Поведенческие] Сгенерировать шаблон 'Наблюдатель' (Observer)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Наблюдатель' (Observer). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>strategy</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        Паттерн 'Наблюдатель' (Observer) используется для установления зависимости типа "один ко многим" между объектами, так что когда один объект меняется, все зависящие от него объекты уведомляются и обновляются автоматически. 
        В сгенерированной действием программе-примере рассмотрен вариант использования паттерна "Наблюдатель" на примере системы уведомлений в социальной сети. 
        У нас есть интерфейс <span class="code">ISubscriber</span>, который определяет метод для обновления подписчиков, и класс <span class="code">SocialMediaPage</span>, 
        который представляет страницу в социальной сети и уведомляет своих подписчиков о новых постах. 
        В данном примере класс <span class="code">SocialMediaPage</span> представляет страницу в социальной сети, которая может иметь несколько подписчиков. 
        Когда на странице появляется новый пост, метод <span class="code">PostNewContent</span> уведомляет всех подписчиков о новом контенте путем вызова метода <span class="code">Update</span> у каждого подписчика. 
        При запуске программы создаются два подписчика, которые добавляются к странице в социальной сети. Затем создается два поста, и каждый подписчик получает уведомление о новом посте. 
        После этого один из подписчиков удаляется, и только один подписчик получит уведомление о последнем посте.
    </p>

    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_state_pattern">[Поведенческие] Сгенерировать шаблон 'Состояние' (State)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Состояние' (State). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>state</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере моделируются следующая ситуация. Представим систему управления заказами в интернет-магазине. В этой системе заказ может находиться в различных состояниях, таких как "новый", "обрабатывается", "отправлен" и "доставлен". 
        Мы можем использовать паттерн "Состояние", чтобы моделировать эти различные состояния и поведение заказа в зависимости от его текущего состояния. 
        В этом примере мы создаем интерфейс <span class="code">IOrderState</span>, который определяет методы для обработки и отмены заказа. 
        Затем мы создаем классы, представляющие конкретные состояния заказа: "Новый", "Обрабатывается" и "Отменен". 
        Класс <span class="code">Order</span> использует текущее состояние для выполнения соответствующих операций. 
        При запуске программы мы создаем заказ, переводим его в состояние "Обрабатывается", пытаемся повторно обработать заказ, отменяем заказ и пытаемся обработать отмененный заказ.  
        В результате мы видим, что поведение заказа изменяется в зависимости от его текущего состояния, что является основным принципом паттерна 'Состояние'.
    </p>

    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_memento_pattern">[Поведенческие] Сгенерировать шаблон 'Хранитель' (Memento)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Хранитель' (Memento). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>memento</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере моделируются следующая ситуация. Представим, что мы разрабатываем текстовый редактор, который должен иметь функциональность отмены и возврата действий (undo/redo). 
        Мы можем использовать паттерн 'Хранитель' (Memento) для сохранения состояния текстового редактора и его истории изменений. 
        В этом примере у нас есть класс <span class="code">TextDocument</span>, который представляет текстовый документ. У него есть методы для обновления текста, отмены (Undo) и возврата (Redo) изменений. 
        Метод <span class="code">Save</span> сохраняет текущее состояние текста в виде объекта <span class="code">TextDocumentMemento</span>, который добавляется в стек <span class="code">_mementos</span>. 
        При запуске программы создается текстовый документ, изменяется его текст, затем выполняется отмена изменений и возврат к предыдущему состоянию. 
        Это демонстрирует использование паттерна Memento для сохранения и восстановления состояния объекта.
    </p>   
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_mediator_pattern">[Поведенческие] Сгенерировать шаблон 'Посредник' (Mediator)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Посредник' (Mediator). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>mediator</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере моделируются следующая ситуация. Допустим, у нас есть система управления авиарейсами, где могут участвовать различные компоненты, такие как билетное агентство, 
        авиакомпания, система бронирования и т.д. Мы можем использовать паттерн Mediator для координации взаимодействия между этими компонентами. 
        В этом примере класс <span class="code">AirTrafficControl</span> выступает в роли посредника, который регистрирует участников и координирует обмен сообщениями между ними. 
        Участники (например, "Авиакомпания", "Система бронирования", "Билетное агентство") могут отправлять сообщения через посредника, и он будет передавать сообщения другим участникам. 
        Пример демонстрирует реализацию типовой задачи для взаимодействия различных компонентов в системе управления авиарейсами. 
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_behavioral_iterator_pattern">[Поведенческие] Сгенерировать шаблон 'Итератор' (Iterator)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение поведенческого шаблона проектирования 'Итератор' (Iterator). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>iterator</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере моделируются следующая ситуация. Допустим, у нас есть класс <span class="code">Student</span> и класс <span class="code">StudentCollection</span>, который реализует интерфейс <span class="code">IEnumerable{T}</span> для итерации по студентам. 
        В этом примере <span class="code">StudentCollection</span> представляет коллекцию студентов, а <span class="code">StudentIterator</span> реализует итератор для этой коллекции. 
        При использовании цикла <span class="code">foreach</span> по объекту <span class="code">studentCollection</span> мы можем перебирать всех студентов в коллекции без необходимости знать детали реализации итерации. 
        Пример демонстрирует реализацию типовой задачи для разработчиков, когда требуется осуществить перебор элементов в коллекции с помощью итератора. 
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_creational_abstract_factory_pattern">[Порождающие] Сгенерировать шаблон 'Абстрактная фабрика' (Abstract Factory)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение порождающего шаблона проектирования 'Абстрактная фабрика' (Abstract Factory). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>abstract_factory</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированном действием примере моделируется ситуация, когда у нас есть необходимость производства деталей для автомобилей разных классов - спорткары и седаны. 
        Класс <span class="code">AbstractCarFactory</span> устанавливает контракт (доступные методы класса) для производства запчастей для автомобилей заданного класса. 
        Класс фабрики умеет изготавливать определённые типы двигателей и корпусов для автомобилей. Классы конкретных фабрик <span class="code">SedanV4CarFactory</span> и <span class="code">SportCarV12CarFactory</span> отвечают за производство 
        деталей для авто заданного типа: первый - детали для седанов, второй - детали для спорткаров. Для получения экземпляра конкретной фабрики достаточно вызвать статический метод <span class="code">AbstractCarFactory.GetFactory{T}</span> у класса 
        абстрактной фабрики и передать ему требуемый тип конкретной фабрики, после чего создавать с помощью полученного экземпляра детали конкретного типа.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_creational_builder_pattern">[Порождающие] Сгенерировать шаблон 'Строитель' (Builder)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение порождающего шаблона проектирования 'Строитель' (Builder). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>builder</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В этом примере класс <span class="code">PizzaOrder</span> представляет заказ пиццы, а интерфейс <span class="code">IPizzaBuilder</span> определяет 
        методы для установки размера пиццы и добавления топпингов к заказу пиццы. Класс <span class="code">MargheritaPizzaBuilder</span> реализует интерфейс <span class="code">IPizzaBuilder</span> для создания заказа пиццы "Маргарита". 
        Директор <span class="code">PizzaDirector</span> управляет процессом сборки заказа пиццы. При запуске программы создается заказ пиццы "Маргарита" с указанными размером и топпингами, после чего он отображается на консоли.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_creational_factory_method_pattern">[Порождающие] Сгенерировать шаблон 'Фабричный метод' (Factory Method)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение порождающего шаблона проектирования 'Фабричный метод' (Factory Method). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>factory_method</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере показан пример кода на C#, демонстрирующий применение порождающего паттерна 'Фабричный метод' (Factory Method) для создания объектов, 
        представляющих различные типы транспортных средств (например, автомобиль, велосипед, самолет). 
        В этом примере классы <span class="code">Car</span>, <span class="code">Bicycle</span> и <span class="code">Airplane</span> представляют различные типы транспортных средств, реализующие интерфейс <span class="code">ITransport</span>. 
        Классы фабрик (<span class="code">CarFactory</span>, <span class="code">BicycleFactory</span>, <span class="code">AirplaneFactory</span>) реализуют абстрактный метод <span class="code">TransportFactory.CreateTransport</span>, 
        который возвращает конкретный экземпляр соответствующего транспортного средства. 
        При запуске программы создаются экземпляры различных типов транспортных средств с помощью соответствующих фабрик, после чего они используются для выполнения действия <span class="code">ITransport.Drive</span>.
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_creational_not_thread_safe_singleton_pattern">[Порождающие] Сгенерировать шаблон 'Одиночка' (Singleton) - не потокобезопасный</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение порождающего шаблона проектирования 'Одиночка' (Singleton), который не является потокобезопасным. 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>not_thread_safe_singleton</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В этом примере класс <span class="code">Logger</span> представляет собой простой логгер, который использует паттерн 'Одиночка' (Singleton) для гарантирования того, 
        что у нас есть только один экземпляр логгера в приложении. Метод <span class="code">Logger.GetInstance</span> возвращает этот единственный экземпляр, и все вызовы 
        <span class="code">Logger.GetInstance()</span> будут возвращать ссылку на один и тот же объект класса <span class="code">Logger</span>. 
        Приведённая в примере реализация паттерна 'Одиночка' не является потокобезопасной, т.е. в случае многопоточного приложения и наличия вероятности обращения разных потоков к 
        методу <span class="code">Logger.GetInstance</span>, программа может повести себя неверно, и разные потоки создадут разные экземпляры класса-синглтона, чего не ожидается от поведения программы. 
        Поэтому данный вариант реализации возможно использовать лишь тогда, когда всегда в один момент времени только один поток запрашивает экземпляр класса <span class="code">Logger</span>. 
        Такой подход с применением шаблона 'Одиночка' полезен, например, для создания глобального логгера или доступа к общим ресурсам, к которым должен иметь доступ только один объект в приложении.
    </p>  
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_creational_thread_safe_singleton_pattern">[Порождающие] Сгенерировать шаблон 'Одиночка' (Singleton) - потокобезопасный</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение порождающего шаблона проектирования 'Одиночка' (Singleton), который является потокобезопасным. 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>thread_safe_singleton</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В этом примере класс <span class="code">Logger</span> представляет собой простой логгер, который использует паттерн 'Одиночка' (Singleton) для гарантирования того, 
        что у нас есть только один экземпляр логгера в приложении. Открытое свойство <span class="code">Logger.Instance</span> возвращает этот единственный экземпляр, и все вызовы 
        <span class="code">Logger.Instance</span> будут возвращать ссылку на один и тот же объект класса <span class="code">Logger</span>. 
        Данная реализация паттерна 'Одиночка' является потокобезопасной, хотя и снижает производительность варианта за счёт дополнительной блокировки внутри свойства <span class="code">Logger.Instance</span>, 
        необходимой для синхронизации потоков при получении единого экземпляра класса-синглтона. 
        Такой подход с применением шаблона 'Одиночка' полезен, например, для создания глобального логгера или доступа к общим ресурсам, к которым должен иметь доступ только один объект в приложении.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_creational_object_pool_pattern">[Порождающие] Сгенерировать шаблон 'Пул объектов' (Object Pool)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение порождающего шаблона проектирования 'Пул объектов' (Object Pool). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>object_pool</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В примере рассмотрена простая реализация паттерна 'Пул объектов' на языке C#, который моделирует пул соединений к базе данных. 
        В этом примере <span class="code">ConnectionPool</span> представляет пул объектов <span class="code">DatabaseConnection</span>, предназначенных для работы с базой данных. 
        При запросе соединения из пула, он возвращает либо существующее соединение, либо создает новое, если все соединения уже заняты. 
        После использования соединение можно освободить обратно в пул для повторного использования. 
        Паттерн 'Пул объектов' полезен, когда создание и уничтожение объектов - дорогостоящие операции, и их повторное использование может повысить производительность приложения.
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_creational_prototype_pattern">[Порождающие] Сгенерировать шаблон 'Прототип' (Prototype)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение порождающего шаблона проектирования 'Прототип' (Prototype). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>prototype</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлена ситуация, когда у нас есть система для создания и редактирования документов, и нам нужно реализовать возможность 
        клонирования существующего документа для создания нового. В этом примере <span class="code">Document</span> представляет конкретный класс документа, который реализует метод <span class="code">DocumentPrototype.Clone</span>, 
        возвращающий клон текущего объекта. При создании клонированного документа мы можем изменить его заголовок, не затрагивая оригинальный документ. 
        Паттерн 'Прототип' полезен, когда необходимо создавать объекты на основе уже существующих объектов с минимальными изменениями. Это позволяет избежать сложных операций по созданию новых объектов с нуля.
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_adapter_pattern">[Структурные] Сгенерировать шаблон 'Адаптер' (Adapter)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Адаптер' (Adapter). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>adapter</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлен пример кода на C#, демонстрирующий использование паттерна 'Адаптер' (Adapter) для преобразования интерфейса одного класса в интерфейс другого класса. 
        Для примера взята ситуация, когда у нас есть сторонняя библиотека, предоставляющая функциональность работы с различными устройствами ввода, и мы хотим использовать эту библиотеку в нашем проекте, но у нас уже есть свой собственный интерфейс 
        для работы с устройствами ввода. В этом примере класс <span class="code">ThirdPartyInputDevice</span> представляет стороннюю библиотеку, <span class="code">IInputDevice</span> - интерфейс в нашем проекте, 
        а <span class="code">InputDeviceAdapter</span> - адаптер, который позволяет использовать функциональность сторонней библиотеки через наш интерфейс. Адаптер позволяет инкапсулировать логику преобразования вызовов методов из нашего интерфейса в вызовы методов сторонней библиотеки.
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_bridge_pattern">[Структурные] Сгенерировать шаблон 'Мост' (Bridge)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Мост' (Bridge). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>bridge</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере рассмотрен пример использования паттерна 'Мост' (Bridge) на языке C# для создания различных типов устройств и их пультов управления. 
        Паттерн 'Мост' позволяет отделить абстракцию от её реализации, чтобы они могли изменяться независимо друг от друга. 
        В этом примере мы создаем абстрактный класс <span class="code">RemoteControl</span>, который представляет пульт управления для устройства. 
        У нас есть два конкретных устройства: <span class="code">TV</span> и <span class="code">Radio</span>, реализующих интерфейс <span class="code">IDevice</span>. 
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_decorator_pattern">[Структурные] Сгенерировать шаблон 'Декоратор' (Decorator)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Декоратор' (Decorator). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>decorator</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере рассмотрен пример использования паттерна 'Декоратор' (Decorator) на языке C# для создания системы управления правами доступа пользователей. 
        В этом примере мы будем добавлять различные уровни доступа к базовому объекту пользователя. В этом примере <span class="code">IUser</span> представляет интерфейс для базового объекта пользователя. 
        Класс <span class="code">User</span> представляет базового пользователя. Декораторы <span class="code">AdminUserDecorator</span> и <span class="code">ModeratorUserDecorator</span> добавляют соответствующие уровни доступа к пользователю. 
        Паттерн 'Декоратор' позволяет динамически добавлять новые функциональности или изменять поведение объекта, не изменяя его основной структуры. 
        При запуске программы можно видеть, как каждый пользователь отображается с учетом своего уровня доступа (администратор или модератор), добавленного через декораторы.
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_composite_pattern">[Структурные] Сгенерировать шаблон 'Компоновщик' (Composite)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Компоновщик' (Composite). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>composite</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлен пример реализации паттерна 'Компоновщик' на языке C# с использованием задачи организации файлов и папок. 
        В этом примере классы <span class="code">File</span> и <span class="code">Folder</span> представляют файлы и папки соответственно и наследуются от абстрактного класса <span class="code">FileSystemItem</span>. 
        Абстрактный класс <span class="code">FileSystemItem</span> определяет общие методы и свойства для файлов и папок. Класс <span class="code">Folder</span> 
        может содержать как файлы, так и другие папки. Метод <span class="code">FileSystemItem.Print</span> вызывается рекурсивно для каждого элемента, что позволяет выводить структуру файловой системы 
        с учетом вложенных элементов.
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_flyweight_pattern">[Структурные] Сгенерировать шаблон 'Приспособленец/Легковес' (Flyweight)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Приспособленец/Легковес' (Flyweight). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>flyweight</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлена тестовая ситуация с использованием задачи о создании веб-страниц.
        В этом примере класс <span class="code">WebPage</span> представляет веб-страницу, интерфейс <span class="code">IWebPage</span> представляет интерфейс приспособленца. Класс <span class="code">WebPageFactory</span> является фабрикой приспособленцев и отвечает за создание 
        и управление экземплярами <span class="code">WebPage</span>. Если веб-страница с заданным содержимым уже существует, фабрика возвращает ранее созданный экземпляр, иначе она создает новый экземпляр и сохраняет его 
        для последующего использования. При вызове метода <span class="code">IWebPage.Display</span> каждая веб-страница отображается с указанной темой. 
        Веб-страницы с одинаковым содержимым используются повторно, что позволяет сэкономить память и уменьшить количество создаваемых объектов. 
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_proxy_pattern">[Структурные] Сгенерировать шаблон 'Заместитель' (Proxy)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Заместитель' (Proxy). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>proxy</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлена ситуация, когда у есть класс, представляющий загрузку изображений из сети. 
        Мы можем использовать паттерн 'Заместитель' (Proxy) для реализации кеширования загруженных изображений, чтобы уменьшить количество запросов к серверу. 
        В этом примере <span class="code">ImageService</span> является реальным сервисом загрузки изображений, а <span class="code">ImageProxy</span> — заместителем, 
        который проверяет наличие изображения в кеше перед загрузкой из сети. Если изображение уже загружено и находится в кеше, заместитель возвращает его из кеша, иначе он делегирует запрос реальному сервису загрузки. 
        При запуске программы можно увидеть, что при повторной загрузке того же изображения оно будет получено из кеша, что помогает уменьшить количество запросов к серверу и повысить производительность.
    </p> 
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_router_pattern">[Структурные] Сгенерировать шаблон 'Маршрутизатор' (Router)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Маршрутизатор' (Router). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>router</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В сгенерированной действием программе-примере представлена ситуация, когда нужно реализовать простой маршрутизатор для веб-приложения. Мы можем использовать паттерн 'Маршрутизатор' (Router) для 
        определения соответствия URL-адресов определенным обработчикам запросов. 
        В этом примере класс <span class="code">Router</span> отображает URL-адреса на соответствующие контроллеры (представлены классами <span class="code">HomeController</span> и <span class="code">AboutController</span>).
        При вызове метода <span class="code">Router.RouteRequest</span> с определенным URL-адресом маршрутизатор проверяет наличие соответствующего контроллера и вызывает метод <span class="code">Index</span> 
        этого контроллера для обработки запроса. При запуске программы-примера можно увидеть, как маршрутизатор направляет запросы к различным контроллерам в зависимости от указанного URL-адреса.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_structural_facade_pattern">[Структурные] Сгенерировать шаблон 'Фасад' (Facade)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение структурного шаблона проектирования 'Фасад' (Facade). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>facade</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        Структурный паттерн 'Фасад' (Façade) позволяет предоставить унифицированный интерфейс к группе интерфейсов подсистемы. 
        В сгенерированном действием примере представлен пример кода на C#, демонстрирующий использование паттерна "Фасад" для работы с различными видами файлов в файловой системе. 
        Класс <span class="code">FileFacade</span> предоставляет упрощенный интерфейс для работы с текстовыми файлами и изображениями, скрывая сложности взаимодействия с соответствующими подсистемами
        <span class="code">TextFileHandler</span> и <span class="code">ImageFileHandler</span>. Разработчики могут использовать <span class="code">FileFacade</span> для открытия, редактирования и 
        сохранения как текстовых файлов, так и изображений, не беспокоясь о деталях реализации каждой операции.
    </p>
    
    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>

	<h3 id="action_generate_technique_cascading_method">[Техники] Сгенерировать пример проекта для техники 'Каскадный метод' (Cascading Method)</h3>
    <p class="justify">Данное действие генерирует в каталоге <b>generated</b> плагина пример готового проекта, демонстрирующего использование и применение техники 'Каскадный метод' (Cascading Method). 
        Пример сгенерированного проекта будет расположен в подкаталоге <b>cascading_method</b> каталога <b>generated</b>.
    </p>
    <p class="justify">
        В этом примере моделируется ситуация, когда есть класс сотрудника <span class="code">Employee</span>, описывающий некоторого сотрудника. 
        У сотрудника есть свойства <span class="code">FullName</span>, <span class="code">Age</span>, <span class="code">Department</span> и <span class="code">Position</span>,
        хранящие полное имя сотрудника, его возраст, департамент, в котором работает сотрудник и занимаемую им должность.
        В методе <span class="code">Main</span> тестовой программы-примера мы создаём три объекта класса <span class="code">Employee</span> посредством применения техники 'Каскадный метод', при
        котором в классе присутствуют методы <span class="code">WithFullName</span>, <span class="code">WithAge</span>, <span class="code">WithDepartment</span> и <span class="code">WithPosition</span>,
        каждый из которых возвращает ссылку также на экземпляр класса <span class="code">Employee</span>. Это позволяет вместо поддержки множества всех необходимых вариаций конструктора для класса 
        поддержать лишь необходимые - для инициализации основных полей/свойств класса, например, <span class="code">FullName</span> и <span class="code">Age</span>.
        А вспомогательные поля/свойства класса мы можем инициализировать следующим образом: в любом порядке вызывать каскадным образом описанные выше специальные методы, возвращаемый тип данных которых - это
        <span class="code">Employee</span>. В технике "Каскадный метод" выражение <span class="code">a.b().c().d()</span> для любого из методов <span class="code">b()</span>, <span class="code">c()</span>, <span class="code">d()</span> 
        всегда приводит возвращаемое каждым методом значение к типу в левой части, т.е. к типу <span class="code">a</span>. Это позволяет "сцепить" методы в любом порядке, образовав из них цепочку вызовов, которая
        последовательно выполняет какие-то действия или модифицирует (как в этом примере) экземпляр класса, к которому применяется цепочка вызовов.        
    </p>

    <a href="#toc" title="К оглавлению">▲ К оглавлению</a>
</body>
</html>