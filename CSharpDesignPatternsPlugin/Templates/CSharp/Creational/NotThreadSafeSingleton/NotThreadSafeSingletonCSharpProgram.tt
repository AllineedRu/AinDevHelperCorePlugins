<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;

namespace AinDevHelperNotThreadSafeSingletonPattern {
    /// <summary>
    /// В этом примере Logger представляет собой простой логгер, который использует паттерн "Одиночка" (Singleton) для гарантирования того, 
    /// что у нас есть только один экземпляр логгера в приложении. Метод <see cref="Logger.GetInstance" /> возвращает этот единственный экземпляр, и все вызовы 
    /// Logger.GetInstance() будут возвращать ссылку на один и тот же объект класса <see cref="Logger" />.
    /// Данная реализация паттерна "Одиночка" не является потокобезопасной, т.е. в случае многопоточного приложения и наличия вероятности обращения разных потоков к
    /// методу Logger.GetInstance, программа может повести себя неверно и разные потоки создадут разные экземпляры класса-синглтона, чего не ожидается от поведения программы.
    /// Поэтому данный вариант реализации возможно использовать лишь тогда, когда всегда в один момент времени только один поток запрашивает экземпляр класса Logger.
    ///
    /// Такой подход с применением шаблона "Одиночка" полезен, например, для создания глобального логгера или доступа к общим ресурсам, 
    /// к которым должен иметь доступ только один объект в приложении.
    /// </summary>
    public static class Program {
        public static void Main() {
            Console.WriteLine("========================================================================");
            Console.WriteLine("Демонстрация применения шаблона проектирования \"Одиночка\" (Singleton).\r\nНе потокобезопасный (not thread-safe) вариант реализации.");
            Console.WriteLine("========================================================================");

            Logger logger1 = Logger.GetInstance();
            logger1.Log("Первая запись в логе");

            Logger logger2 = Logger.GetInstance();
            logger2.Log("Вторая запись в логе");

            logger1.PrintLog(); // Выведет обе записи
        }
    } 
}
