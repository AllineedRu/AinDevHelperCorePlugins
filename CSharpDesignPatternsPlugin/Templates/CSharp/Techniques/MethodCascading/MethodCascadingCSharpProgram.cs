/*
Copyright 2024 Allineed.Ru, Max Damascus

Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
and associated documentation files (the "Software"), to deal in the Software without restriction, 
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// ------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Версия среды выполнения: 17.0.0.0
//  
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторного создания кода.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace CSharpDesignPatternsPlugin.Templates.CSharp.Techniques.MethodCascading
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Techniques\MethodCascading\MethodCascadingCSharpProgram.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    public partial class MethodCascadingCSharpProgram : MethodCascadingCSharpProgramBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("using System;\r\n\r\nnamespace AinDevHelperMethodCascadingTechniqueExample {\r\n    ///" +
                    " <summary>\r\n    /// Представим ситуацию, где у нас есть класс <see cref=\"Employe" +
                    "e\"/>, который описывает какого-то сотрудника.\r\n    /// У сотрудника есть свойств" +
                    "а:\r\n    ///     FullName    - полное имя сотрудника\r\n    ///     Age         - в" +
                    "озраст сотрудника\r\n    ///     Department  - департамент, в котором работает сот" +
                    "рудник\r\n    ///     Position    - должность, занимаемая сотрудником\r\n    /// В м" +
                    "етоде Main этой тестовой программы мы создаём три объекта класса <see cref=\"Empl" +
                    "oyee\"/> посредством применения техники \r\n    /// \"Каскадный метод\" (Method Casca" +
                    "ding), при которой в классе присутствуют методы <see cref=\"Employee.WithAge(shor" +
                    "t)\"/>, <see cref=\"Employee.WithFullName(string)\"/>,\r\n    /// <see cref=\"Employee" +
                    ".WithDepartment(string)\"/>, <see cref=\"Employee.WithPosition(string)\"/>, которые" +
                    " возвращает ссылку также\r\n    /// на экземпляр класса <see cref=\"Employee\"/>.\r\n " +
                    "   /// \r\n    /// Это позволяет вместо поддержки множества всех необходимых вариа" +
                    "ций конструктора для класса поддержать лишь необходимые - для инициализации осно" +
                    "вных\r\n    /// полей/свойств класса, например <see cref=\"Employee.FullName\"/> и <" +
                    "see cref=\"Employee.Age\"/>. \r\n    /// А вспомогательные поля/свойства класса мы м" +
                    "ожем инициализировать следующим образом: в любом порядке вызывать\r\n    /// каска" +
                    "дным образом описанные выше специальные методы, возвращаемый тип данных которых " +
                    "также <see cref=\"Employee\"/>.\r\n    /// \r\n    /// В технике \"Каскадный метод\" выр" +
                    "ажение a.b().c().d() для любого из методов b(), c(), d() всегда приводит возвращ" +
                    "аемое каждым методом значение\r\n    /// к типу в левой части, т.е. к типу \'a\'. Эт" +
                    "о позволяет \"сцепить\" методы в любом порядке, образовав из них цепочку вызовов, " +
                    "которая\r\n    /// последовательно выполняет какие-то действия или модифицирует (к" +
                    "ак в этом примере) экземпляр класса, к которому применяется цепочка вызовов.\r\n  " +
                    "  /// </summary>\r\n    public static class Program {\r\n\r\n        public static voi" +
                    "d Main(string[] args) {\r\n            Console.WriteLine(\"========================" +
                    "===============================================\");\r\n            Console.WriteLin" +
                    "e(\"Демонстрация применения техники \\\"Каскадный метод\\\" (Method Cascading)\");\r\n  " +
                    "          Console.WriteLine(\"===================================================" +
                    "====================\");\r\n\r\n            // Можно создать сотрудника и сразу приме" +
                    "нить необходимые изменения к созданному экземпляру сотрудника -\r\n            // " +
                    "присвоить ему требуемую должность, полное имя, возраст и департамент, в котором " +
                    "он работает.\r\n            // Порядок вызова методов в цепочке при технике \"каска" +
                    "дного метода\" не играет роли, т.к. \r\n            // любой из методов возвращает " +
                    "текущий экземпляр сотрудника, тип данных которого также Employee\r\n            Em" +
                    "ployee employee1 = new Employee()\r\n                                .WithPosition" +
                    "(\"Старший научный сотрудник\")\r\n                                .WithFullName(\"Ва" +
                    "силий Васильев\")\r\n                                .WithDepartment(\"Департамент н" +
                    "аучных исследований\")\r\n                                .WithAge(45);\r\n\r\n        " +
                    "    Console.WriteLine($\"Сотрудник 1:\\r\\n\\t{employee1}\");\r\n\r\n            // Можно" +
                    " также сначала создать сотрудника вообще без инициализации его полей, вызвав кон" +
                    "структор без параметров\r\n            Employee employee2 = new Employee();\r\n     " +
                    "       Console.WriteLine($\"Сотрудник 2 сразу после создания экземпляра класса с " +
                    "вызовом конструктора без параметров:\\r\\n\\t{employee2}\");\r\n\r\n            // А зат" +
                    "ем к этому же экземпляру применить нужные изменения свойств сотрудника, в любом " +
                    "порядке, применяя технику\r\n            // \"каскадного метода\"\r\n            emplo" +
                    "yee2 = employee2.WithFullName(\"Иван Иванов\")\r\n                                .W" +
                    "ithAge(32)\r\n                                .WithPosition(\"Менеджер\")\r\n         " +
                    "                       .WithDepartment(\"Финансовый департамент\");\r\n            C" +
                    "onsole.WriteLine($\"Сотрудник 2 после инициализации свойств для уже созданного эк" +
                    "земпляра:\\r\\n\\t{employee2}\");\r\n\r\n            // Можно также создать сначала сотр" +
                    "удника лишь с инициализированными основными полями\r\n            Employee employe" +
                    "e3 = new Employee(\"Сергей Сергеев\", 21);\r\n            Console.WriteLine($\"Сотруд" +
                    "ник 3 сразу после создания:\\r\\n\\t{employee3}\");\r\n\r\n            // А позже измени" +
                    "ть этот объект, дополнив дополнительными сведениями через применение техники \"Ка" +
                    "скадный метод\"\r\n            employee3 = employee3.WithPosition(\"Стажёр\")\r\n      " +
                    "                          .WithDepartment(\"Департамент информационных технологий" +
                    "\");\r\n\r\n            Console.WriteLine($\"Сотрудник 3 после инициализации дополните" +
                    "льных свойств:\\r\\n\\t{employee3}\");\r\n        }\r\n    }    \r\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    public class MethodCascadingCSharpProgramBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
