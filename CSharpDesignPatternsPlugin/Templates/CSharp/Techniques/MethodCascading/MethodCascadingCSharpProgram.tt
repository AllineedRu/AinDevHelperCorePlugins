<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;

namespace AinDevHelperMethodCascadingTechniqueExample {
    /// <summary>
    /// Представим ситуацию, где у нас есть класс <see cref="Employee"/>, который описывает какого-то сотрудника.
    /// У сотрудника есть свойства:
    ///     FullName    - полное имя сотрудника
    ///     Age         - возраст сотрудника
    ///     Department  - департамент, в котором работает сотрудник
    ///     Position    - должность, занимаемая сотрудником
    /// В методе Main этой тестовой программы мы создаём три объекта класса <see cref="Employee"/> посредством применения техники 
    /// "Каскадный метод" (Method Cascading), при которой в классе присутствуют методы <see cref="Employee.WithAge(short)"/>, <see cref="Employee.WithFullName(string)"/>,
    /// <see cref="Employee.WithDepartment(string)"/>, <see cref="Employee.WithPosition(string)"/>, которые возвращает ссылку также
    /// на экземпляр класса <see cref="Employee"/>.
    /// 
    /// Это позволяет вместо поддержки множества всех необходимых вариаций конструктора для класса поддержать лишь необходимые - для инициализации основных
    /// полей/свойств класса, например <see cref="Employee.FullName"/> и <see cref="Employee.Age"/>. 
    /// А вспомогательные поля/свойства класса мы можем инициализировать следующим образом: в любом порядке вызывать
    /// каскадным образом описанные выше специальные методы, возвращаемый тип данных которых также <see cref="Employee"/>.
    /// 
    /// В технике "Каскадный метод" выражение a.b().c().d() для любого из методов b(), c(), d() всегда приводит возвращаемое каждым методом значение
    /// к типу в левой части, т.е. к типу 'a'. Это позволяет "сцепить" методы в любом порядке, образовав из них цепочку вызовов, которая
    /// последовательно выполняет какие-то действия или модифицирует (как в этом примере) экземпляр класса, к которому применяется цепочка вызовов.
    /// </summary>
    public static class Program {

        public static void Main(string[] args) {
            Console.WriteLine("=======================================================================");
            Console.WriteLine("Демонстрация применения техники \"Каскадный метод\" (Method Cascading)");
            Console.WriteLine("=======================================================================");

            // Можно создать сотрудника и сразу применить необходимые изменения к созданному экземпляру сотрудника -
            // присвоить ему требуемую должность, полное имя, возраст и департамент, в котором он работает.
            // Порядок вызова методов в цепочке при технике "каскадного метода" не играет роли, т.к. 
            // любой из методов возвращает текущий экземпляр сотрудника, тип данных которого также Employee
            Employee employee1 = new Employee()
                                .WithPosition("Старший научный сотрудник")
                                .WithFullName("Василий Васильев")
                                .WithDepartment("Департамент научных исследований")
                                .WithAge(45);

            Console.WriteLine($"Сотрудник 1:\r\n\t{employee1}");

            // Можно также сначала создать сотрудника вообще без инициализации его полей, вызвав конструктор без параметров
            Employee employee2 = new Employee();
            Console.WriteLine($"Сотрудник 2 сразу после создания экземпляра класса с вызовом конструктора без параметров:\r\n\t{employee2}");

            // А затем к этому же экземпляру применить нужные изменения свойств сотрудника, в любом порядке, применяя технику
            // "каскадного метода"
            employee2 = employee2.WithFullName("Иван Иванов")
                                .WithAge(32)
                                .WithPosition("Менеджер")
                                .WithDepartment("Финансовый департамент");
            Console.WriteLine($"Сотрудник 2 после инициализации свойств для уже созданного экземпляра:\r\n\t{employee2}");

            // Можно также создать сначала сотрудника лишь с инициализированными основными полями
            Employee employee3 = new Employee("Сергей Сергеев", 21);
            Console.WriteLine($"Сотрудник 3 сразу после создания:\r\n\t{employee3}");

            // А позже изменить этот объект, дополнив дополнительными сведениями через применение техники "Каскадный метод"
            employee3 = employee3.WithPosition("Стажёр")
                                .WithDepartment("Департамент информационных технологий");

            Console.WriteLine($"Сотрудник 3 после инициализации дополнительных свойств:\r\n\t{employee3}");
        }
    }    
}