/*
Copyright 2024 Allineed.Ru, Max Damascus

Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
and associated documentation files (the "Software"), to deal in the Software without restriction, 
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// ------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Версия среды выполнения: 17.0.0.0
//  
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторного создания кода.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace CSharpDesignPatternsPlugin.Templates.CSharp.Structural.Proxy
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using AinDevHelperPluginLibrary.Language;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    public partial class ProxyCSharpProgram : ProxyCSharpProgramBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("using System;\r\n\r\nnamespace AinDevHelperProxyPattern {\r\n    /// <summary>\r\n");
            
            #line 11 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 if (AinDevHelperLanguageCodeConstants.EN.Equals(LanguageCode)) { 
            
            #line default
            #line hidden
            this.Write(@"    /// Let's imagine a situation where we have a class that represents downloading images from the web. 
    /// We can use the 'Proxy' pattern to implement caching of downloaded images to reduce the number of requests to the server. 
    /// Below is a sample C# code that demonstrates this.
    ///
    /// In this example, <see cref=""ImageService"" /> is the actual image download service, and <see cref=""ImageProxy"" /> is a proxy 
    /// that checks for the image to be cached before downloading it from the network. If the image is already downloaded and is in the cache, 
    /// the proxy returns it from the cache, otherwise it delegates the request to the real download service.
    ///
    /// When you run the program, you can see that if you download the same image again, it will be retrieved from the cache, 
    /// which helps reduce the number of requests to the server and improve performance.
");
            
            #line 22 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } else if (AinDevHelperLanguageCodeConstants.DE.Equals(LanguageCode)) { 
            
            #line default
            #line hidden
            this.Write(@"    /// Stellen wir uns eine Situation vor, in der wir eine Klasse haben, die das Herunterladen von Bildern aus dem Internet darstellt. 
    /// Wir können das Proxy-Muster verwenden, um die Zwischenspeicherung heruntergeladener Bilder zu implementieren und so die Anzahl der Anfragen an den Server zu reduzieren. 
    /// Unten finden Sie einen Beispiel-C#-Code, der dies demonstriert.
    ///
    /// In diesem Beispiel ist <see cref=""ImageService"" /> der eigentliche Bild-Download-Dienst und <see cref=""ImageProxy"" /> ein Proxy, 
    /// der prüft, ob das Bild zwischengespeichert wird, bevor es aus dem Netzwerk heruntergeladen wird. Wenn das Bild bereits heruntergeladen wurde und sich 
    /// im Cache befindet, gibt der Proxy es aus dem Cache zurück, andernfalls delegiert er die Anfrage an den echten Download-Dienst.
    ///
    /// Wenn Sie das Programm ausführen, können Sie sehen, dass, wenn Sie dasselbe Bild erneut herunterladen, es aus dem Cache abgerufen wird, 
    /// was dazu beiträgt, die Anzahl der Anfragen an den Server zu reduzieren und die Leistung zu verbessern.
");
            
            #line 33 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } else { 
            
            #line default
            #line hidden
            this.Write(@"    /// Представим ситуацию, когда у нас есть класс, представляющий загрузку изображений из сети. 
    /// Мы можем использовать паттерн ""Заместитель"" (Proxy) для реализации кеширования загруженных изображений, чтобы уменьшить количество запросов к серверу. 
    /// Ниже показан пример кода на C#, демонстрирующий это.
    ///
    /// В этом примере <see cref=""ImageService"" /> является реальным сервисом загрузки изображений, а <see cref=""ImageProxy"" /> — заместителем, 
    /// который проверяет наличие изображения в кеше перед загрузкой из сети. Если изображение уже загружено и находится в кеше, заместитель 
    /// возвращает его из кеша, иначе он делегирует запрос реальному сервису загрузки.
    ///
    /// При запуске программы можно увидеть, что при повторной загрузке того же изображения оно будет получено из кеша, что помогает уменьшить 
    /// количество запросов к серверу и повысить производительность.
");
            
            #line 44 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } 
            
            #line default
            #line hidden
            this.Write("    /// </summary>\r\n    public static class Program {\r\n        public static void" +
                    " Main() {\r\n            Console.WriteLine(\"======================================" +
                    "=======================================\");\r\n");
            
            #line 49 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 if (AinDevHelperLanguageCodeConstants.EN.Equals(LanguageCode)) { 
            
            #line default
            #line hidden
            this.Write("            Console.WriteLine(\"Demonstration of the \\\"Proxy\\\" Design Pattern\");\r\n" +
                    "");
            
            #line 51 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } else if (AinDevHelperLanguageCodeConstants.DE.Equals(LanguageCode)) { 
            
            #line default
            #line hidden
            this.Write("            Console.WriteLine(\"Demonstration des „Proxy“-Musters\");\r\n");
            
            #line 53 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } else { 
            
            #line default
            #line hidden
            this.Write("            Console.WriteLine(\"Демонстрация применения шаблона проектирования \\\"З" +
                    "аместитель\\\" (Proxy)\");\r\n");
            
            #line 55 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } 
            
            #line default
            #line hidden
            this.Write("            Console.WriteLine(\"==================================================" +
                    "===========================\");            \r\n\r\n");
            
            #line 58 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 if (AinDevHelperLanguageCodeConstants.EN.Equals(LanguageCode)) { 
            
            #line default
            #line hidden
            this.Write(@"            // Using a proxy to load and cache images
            IImageService imageProxy = new ImageProxy();

            // First image upload (must be from server)
            imageProxy.DisplayImage(""image1.jpg"");

            // Re-downloading the same image (must be from cache)
            imageProxy.DisplayImage(""image1.jpg"");

            // Uploading another image (must be from the server)
            imageProxy.DisplayImage(""image2.jpg"");
");
            
            #line 70 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } else if (AinDevHelperLanguageCodeConstants.DE.Equals(LanguageCode)) { 
            
            #line default
            #line hidden
            this.Write(@"            // Verwenden eines Proxys zum Laden und Zwischenspeichern von Bildern
            IImageService imageProxy = new ImageProxy();

            // Erster Bild-Upload (muss vom Server erfolgen)
            imageProxy.DisplayImage(""Bild1.jpg"");

            // Dasselbe Bild erneut herunterladen (muss aus dem Cache stammen)
            imageProxy.DisplayImage(""Bild1.jpg"");

            // Ein weiteres Bild hochladen (muss vom Server stammen)
            imageProxy.DisplayImage(""Bild2.jpg"");
");
            
            #line 82 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } else { 
            
            #line default
            #line hidden
            this.Write(@"            // Используем заместитель для загрузки и кеширования изображений
            IImageService imageProxy = new ImageProxy();

            // Первая загрузка изображения (должна быть с сервера)
            imageProxy.DisplayImage(""изображение1.jpg"");

            // Повторная загрузка того же изображения (должна быть из кеша)
            imageProxy.DisplayImage(""изображение1.jpg"");

            // Загрузка другого изображения (должна быть с сервера)
            imageProxy.DisplayImage(""изображение2.jpg"");
");
            
            #line 94 "C:\Users\1\source\repos\AinDevHelperCorePlugins\CSharpDesignPatternsPlugin\Templates\CSharp\Structural\Proxy\ProxyCSharpProgram.tt"
 } 
            
            #line default
            #line hidden
            this.Write("        }\r\n    }\r\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "17.0.0.0")]
    public class ProxyCSharpProgramBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
